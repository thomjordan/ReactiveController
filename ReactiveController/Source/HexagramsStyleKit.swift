//
//  HexagramsStyleKit.swift
//  ReactiveController
//
//  Created by ThomJordan on 8/23/17.
//  Copyright © 2017 Rationum. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import Cocoa

public class HexagramsStyleKit : NSObject {
    
    //// Drawing Methods
    
    @objc dynamic public class func drawHexagramTile(frame targetFrame: NSRect = NSRect(x: 0, y: 0, width: 35, height: 35), resizing: ResizingBehavior = .aspectFit, wenSelector: CGFloat = 1, ledSelector: CGFloat = 0, h1: String = "䷀", h2: String = "䷁", h3: String = "䷂", h4: String = "䷃", h5: String = "䷄", h6: String = "䷅", h7: String = "䷆", h8: String = "䷇", h9: String = "䷈", h10: String = "䷉", h11: String = "䷊", h12: String = "䷋", h13: String = "䷌", h14: String = "䷍", h15: String = "䷎", h16: String = "䷏", h17: String = "䷐", h18: String = "䷑", h19: String = "䷒", h20: String = "䷓", h21: String = "䷔", h22: String = "䷕", h23: String = "䷖", h24: String = "䷗", h25: String = "䷘", h26: String = "䷙", h27: String = "䷚", h28: String = "䷛", h29: String = "䷜", h30: String = "䷝", h31: String = "䷞", h32: String = "䷟", h33: String = "䷠", h34: String = "䷡", h35: String = "䷢", h36: String = "䷣", h37: String = "䷤", h38: String = "䷥", h39: String = "䷦", h40: String = "䷧", h41: String = "䷨", h42: String = "䷩", h43: String = "䷪", h44: String = "䷫", h45: String = "䷬", h46: String = "䷭", h47: String = "䷮", h48: String = "䷯", h49: String = "䷰", h50: String = "䷱", h51: String = "䷲", h52: String = "䷳", h53: String = "䷴", h54: String = "䷵", h55: String = "䷶", h56: String = "䷷", h57: String = "䷸", h58: String = "䷹", h59: String = "䷺", h60: String = "䷻", h61: String = "䷼", h62: String = "䷽", h63: String = "䷾", h64: String = "䷿", size: CGFloat = 35) {
        //// General Declarations
        let context = NSGraphicsContext.current!.cgContext
        
        //// Resize to Target Frame
        NSGraphicsContext.saveGraphicsState()
        let resizedFrame: NSRect = resizing.apply(rect: NSRect(x: 0, y: 0, width: 35, height: 35), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 35, y: resizedFrame.height / 35)
        let resizedShadowScale: CGFloat = min(resizedFrame.width / 35, resizedFrame.height / 35)
        
        
        //// Color Declarations
        let darkIndigo = NSColor(red: 0.061, green: 0.061, blue: 0.062, alpha: 0.843)
        let indigoShadow = NSColor(red: 0.539, green: 0.528, blue: 0.604, alpha: 1)
        let blueberryGradient = NSColor(red: 0.998, green: 0.999, blue: 1, alpha: 1)
        let darkerBlueberryGradient = NSColor(red: 0.703, green: 0.718, blue: 0.901, alpha: 1)
        let lime = NSColor(red: 0.591, green: 1, blue: 0.306, alpha: 0.45)
        let amber = NSColor(red: 1, green: 1, blue: 0.618, alpha: 0.42)
        let salmon = NSColor(red: 1, green: 0.718, blue: 0.306, alpha: 0.407)
        
        //// Gradient Declarations
        let gradient = NSGradient(colors: [blueberryGradient, blueberryGradient.blended(withFraction: 0.5, of: darkerBlueberryGradient)!, darkerBlueberryGradient], atLocations: [0.0, 0.51, 0.90], colorSpace: NSColorSpace.sRGB)!
        
        //// Shadow Declarations
        let shadow = NSShadow()
        shadow.shadowColor = indigoShadow.withAlphaComponent(0.56 * indigoShadow.alphaComponent)
        shadow.shadowOffset = NSSize(width: 0, height: 1)
        shadow.shadowBlurRadius = 3
        
        //// Variable Declarations
        let wennum: CGFloat = wenSelector > 0 ? fmod((wenSelector - 1), 64) + 1 : 1
        let startsLED: Bool = fmod(ledSelector, 4) == 1 ? true : false
        let midsLED: Bool = fmod(ledSelector, 4) == 2 ? true : false
        let endsLED: Bool = fmod(ledSelector, 4) == 3 ? true : false
        let hexagram: String = wennum == 1 ? h1 : (wennum == 2 ? h2 : (wennum == 3 ? h3 : (wennum == 4 ? h4 : (wennum == 5 ? h5 : (wennum == 6 ? h6 : (wennum == 7 ? h7 : (wennum == 8 ? h8 : (wennum == 9 ? h9 : (wennum == 10 ? h10 : (wennum == 11 ? h11 : (wennum == 12 ? h12 : (wennum == 13 ? h13 : (wennum == 14 ? h14 : (wennum == 15 ? h15 : (wennum == 16 ? h16 : (wennum == 17 ? h17 : (wennum == 18 ? h18 : (wennum == 19 ? h19 : (wennum == 20 ? h20 : (wennum == 21 ? h21 : (wennum == 22 ? h22 : (wennum == 23 ? h23 : (wennum == 24 ? h24 : (wennum == 25 ? h25 : (wennum == 26 ? h26 : (wennum == 27 ? h27 : (wennum == 28 ? h28 : (wennum == 29 ? h29 : (wennum == 30 ? h30 : (wennum == 31 ? h31 : (wennum == 32 ? h32 : (wennum == 33 ? h33 : (wennum == 34 ? h34 : (wennum == 35 ? h35 : (wennum == 36 ? h36 : (wennum == 37 ? h37 : (wennum == 38 ? h38 : (wennum == 39 ? h39 : (wennum == 40 ? h40 : (wennum == 41 ? h41 : (wennum == 42 ? h42 : (wennum == 43 ? h43 : (wennum == 44 ? h44 : (wennum == 45 ? h45 : (wennum == 46 ? h46 : (wennum == 47 ? h47 : (wennum == 48 ? h48 : (wennum == 49 ? h49 : (wennum == 50 ? h50 : (wennum == 51 ? h51 : (wennum == 52 ? h52 : (wennum == 53 ? h53 : (wennum == 54 ? h54 : (wennum == 55 ? h55 : (wennum == 56 ? h56 : (wennum == 57 ? h57 : (wennum == 58 ? h58 : (wennum == 59 ? h59 : (wennum == 60 ? h60 : (wennum == 61 ? h61 : (wennum == 62 ? h62 : (wennum == 63 ? h63 : h64))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
        
        //// HexagramPanel
        //// Container Drawing
        let containerPath = NSBezierPath(rect: NSRect(x: 0, y: -0, width: size, height: size))
        gradient.draw(in: containerPath, angle: -45)
        
        ////// Container Inner Shadow
        NSGraphicsContext.saveGraphicsState()
        containerPath.bounds.clip()
        context.setShadow(offset: NSSize.zero, blur: 0, color: nil)
        
        context.setAlpha(shadow.shadowColor!.alphaComponent)
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        let containerOpaqueShadow = NSShadow()
        containerOpaqueShadow.shadowColor = shadow.shadowColor!.withAlphaComponent(1)
        containerOpaqueShadow.shadowOffset = NSSize(width: shadow.shadowOffset.width * resizedShadowScale, height: shadow.shadowOffset.height * resizedShadowScale)
        containerOpaqueShadow.shadowBlurRadius = shadow.shadowBlurRadius * resizedShadowScale
        containerOpaqueShadow.set()
        
        context.setBlendMode(.sourceOut)
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        
        containerOpaqueShadow.shadowColor!.setFill()
        containerPath.fill()
        
        context.endTransparencyLayer()
        context.endTransparencyLayer()
        NSGraphicsContext.restoreGraphicsState()
        
        NSGraphicsContext.saveGraphicsState()
        context.setShadow(offset: NSSize(width: shadow.shadowOffset.width * resizedShadowScale, height: shadow.shadowOffset.height * resizedShadowScale), blur: shadow.shadowBlurRadius * resizedShadowScale, color: shadow.shadowColor!.cgColor)
        darkIndigo.setStroke()
        containerPath.lineWidth = 1
        containerPath.lineJoinStyle = .bevelLineJoinStyle
        containerPath.stroke()
        NSGraphicsContext.restoreGraphicsState()
        
        
        //// glyph Drawing
        let glyphRect = NSRect(x: 0, y: 0, width: size, height: size)
        let glyphStyle = NSMutableParagraphStyle()
        glyphStyle.alignment = .center
        let glyphFontAttributes = [
            .font: NSFont.systemFont(ofSize: size, weight: NSFont.Weight.heavy),
            .foregroundColor: NSColor.black,
            .paragraphStyle: glyphStyle,
            ] as [NSAttributedStringKey: Any]
        
        let glyphTextHeight: CGFloat = hexagram.boundingRect(with: NSSize(width: glyphRect.width, height: CGFloat.infinity), options: .usesLineFragmentOrigin, attributes: glyphFontAttributes).height
        let glyphTextRect: NSRect = NSRect(x: glyphRect.minX, y: glyphRect.minY + (glyphRect.height - glyphTextHeight) / 2, width: glyphRect.width, height: glyphTextHeight)
        NSGraphicsContext.saveGraphicsState()
        glyphRect.clip()
        hexagram.draw(in: glyphTextRect.offsetBy(dx: 0, dy: 1), withAttributes: glyphFontAttributes)
        NSGraphicsContext.restoreGraphicsState()
        
        
        if (startsLED) {
            //// limeLED Drawing
            let limeLEDPath = NSBezierPath(rect: NSRect(x: 0, y: 0, width: size, height: size))
            lime.setFill()
            limeLEDPath.fill()
            NSColor.gray.setStroke()
            limeLEDPath.lineWidth = 0.5
            limeLEDPath.stroke()
        }
        
        
        if (midsLED) {
            //// amberLED Drawing
            let amberLEDPath = NSBezierPath(rect: NSRect(x: 0, y: 0, width: size, height: size))
            amber.setFill()
            amberLEDPath.fill()
            NSColor.gray.setStroke()
            amberLEDPath.lineWidth = 0.5
            amberLEDPath.stroke()
        }
        
        
        if (endsLED) {
            //// salmonLED Drawing
            let salmonLEDPath = NSBezierPath(rect: NSRect(x: 0, y: 0, width: size, height: size))
            salmon.setFill()
            salmonLEDPath.fill()
            NSColor.gray.setStroke()
            salmonLEDPath.lineWidth = 0.5
            salmonLEDPath.stroke()
        }
        
        NSGraphicsContext.restoreGraphicsState()
        
    }
    
    @objc dynamic public class func drawHexagramPad(frame targetFrame: NSRect = NSRect(x: 0, y: 0, width: 35, height: 35), resizing: ResizingBehavior = .aspectFit, wenSelector: CGFloat = 1, ledSelector: CGFloat = 0) {
        //// General Declarations
        let context = NSGraphicsContext.current!.cgContext
        
        //// Resize to Target Frame
        NSGraphicsContext.saveGraphicsState()
        let resizedFrame: NSRect = resizing.apply(rect: NSRect(x: 0, y: 0, width: 35, height: 35), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 35, y: resizedFrame.height / 35)
        
        
        //// ModularHexagram Drawing
        let modularHexagramRect = NSRect(x: 0, y: 0, width: 35, height: 35)
        NSGraphicsContext.saveGraphicsState()
        modularHexagramRect.clip()
        context.translateBy(x: modularHexagramRect.minX, y: modularHexagramRect.minY)
        
        HexagramsStyleKit.drawHexagramTile(frame: CGRect(origin: .zero, size: modularHexagramRect.size), resizing: .stretch, wenSelector: wenSelector, ledSelector: ledSelector, h1: "䷀", h2: "䷁", h3: "䷂", h4: "䷃", h5: "䷄", h6: "䷅", h7: "䷆", h8: "䷇", h9: "䷈", h10: "䷉", h11: "䷊", h12: "䷋", h13: "䷌", h14: "䷍", h15: "䷎", h16: "䷏", h17: "䷐", h18: "䷑", h19: "䷒", h20: "䷓", h21: "䷔", h22: "䷕", h23: "䷖", h24: "䷗", h25: "䷘", h26: "䷙", h27: "䷚", h28: "䷛", h29: "䷜", h30: "䷝", h31: "䷞", h32: "䷟", h33: "䷠", h34: "䷡", h35: "䷢", h36: "䷣", h37: "䷤", h38: "䷥", h39: "䷦", h40: "䷧", h41: "䷨", h42: "䷩", h43: "䷪", h44: "䷫", h45: "䷬", h46: "䷭", h47: "䷮", h48: "䷯", h49: "䷰", h50: "䷱", h51: "䷲", h52: "䷳", h53: "䷴", h54: "䷵", h55: "䷶", h56: "䷷", h57: "䷸", h58: "䷹", h59: "䷺", h60: "䷻", h61: "䷼", h62: "䷽", h63: "䷾", h64: "䷿", size: 35)
        NSGraphicsContext.restoreGraphicsState()
        
        NSGraphicsContext.restoreGraphicsState()
        
    }
    
    
    
    
    @objc(HexagramsStyleKitResizingBehavior)
    public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.
        
        public func apply(rect: NSRect, target: NSRect) -> NSRect {
            if rect == target || target == NSRect.zero {
                return rect
            }
            
            var scales = NSSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)
            
            switch self {
            case .aspectFit:
                scales.width = min(scales.width, scales.height)
                scales.height = scales.width
            case .aspectFill:
                scales.width = max(scales.width, scales.height)
                scales.height = scales.width
            case .stretch:
                break
            case .center:
                scales.width = 1
                scales.height = 1
            }
            
            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}

